<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BitLife Prison Escape Solver</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        
        .container {
            background: white;
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            max-width: 900px;
            width: 100%;
        }
        
        h1 {
            color: #333;
            margin-bottom: 10px;
            text-align: center;
        }
        
        .subtitle {
            text-align: center;
            color: #666;
            margin-bottom: 25px;
            font-size: 14px;
        }
        
        .setup {
            margin-bottom: 25px;
            padding: 20px;
            background: #f8f9fa;
            border-radius: 10px;
        }
        
        .setup-row {
            display: flex;
            gap: 15px;
            margin-bottom: 15px;
            align-items: center;
            flex-wrap: wrap;
        }
        
        .setup-row label {
            font-weight: 600;
            color: #555;
            min-width: 80px;
        }
        
        .setup-row input, .setup-row select {
            padding: 8px 12px;
            border: 2px solid #ddd;
            border-radius: 5px;
            font-size: 14px;
            transition: border-color 0.3s;
        }
        
        .setup-row input:focus, .setup-row select:focus {
            outline: none;
            border-color: #667eea;
        }
        
        button {
            background: #667eea;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            transition: background 0.3s;
        }
        
        button:hover {
            background: #5568d3;
        }
        
        button:disabled {
            background: #ccc;
            cursor: not-allowed;
        }
        
        .mode-buttons {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }
        
        .mode-btn {
            flex: 1;
            min-width: 120px;
            padding: 12px;
            background: #e9ecef;
            color: #333;
        }
        
        .mode-btn.active {
            background: #667eea;
            color: white;
        }
        
        .grid-container {
            display: inline-block;
            background: #f0f0f0;
            padding: 20px;
            border-radius: 10px;
            margin-bottom: 20px;
        }
        
        .grid {
            display: inline-grid;
            gap: 0;
            background: #333;
            border: 3px solid #333;
        }
        
        .cell {
            width: 50px;
            height: 50px;
            background: white;
            border: 1px solid #ddd;
            position: relative;
            cursor: pointer;
            transition: background 0.2s;
        }
        
        .cell:hover {
            background: #f0f0f0;
        }
        
        .cell.player {
            background: #4CAF50;
            font-weight: bold;
            color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
        }
        
        .cell.guard {
            background: #f44336;
            font-weight: bold;
            color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
        }
        
        .cell.exit {
            background: #FFD700;
            font-weight: bold;
            color: #333;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
        }
        
        .exit-marker {
            position: absolute;
            width: 30px;
            height: 30px;
            background: #FFD700;
            border: 3px solid #FFA500;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
            cursor: pointer;
            z-index: 10;
            box-shadow: 0 2px 8px rgba(0,0,0,0.3);
        }
        
        .exit-marker:hover {
            transform: scale(1.1);
            transition: transform 0.2s;
        }
        
        .cell.path {
            background: #90EE90;
        }
        
        .wall-top {
            position: absolute;
            top: -2px;
            left: 0;
            right: 0;
            height: 4px;
            background: #333;
        }
        
        .wall-right {
            position: absolute;
            right: -2px;
            top: 0;
            bottom: 0;
            width: 4px;
            background: #333;
        }
        
        .wall-bottom {
            position: absolute;
            bottom: -2px;
            left: 0;
            right: 0;
            height: 4px;
            background: #333;
        }
        
        .wall-left {
            position: absolute;
            left: -2px;
            top: 0;
            bottom: 0;
            width: 4px;
            background: #333;
        }
        
        .instructions {
            background: #e7f3ff;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
            border-left: 4px solid #2196F3;
        }
        
        .instructions h3 {
            color: #1976D2;
            margin-bottom: 10px;
        }
        
        .instructions ul {
            margin-left: 20px;
            color: #555;
        }
        
        .instructions li {
            margin-bottom: 5px;
        }
        
        .solution {
            background: #e8f5e9;
            padding: 20px;
            border-radius: 8px;
            border-left: 4px solid #4CAF50;
        }
        
        .solution h3 {
            color: #2E7D32;
            margin-bottom: 15px;
        }
        
        .moves {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            margin-top: 10px;
        }
        
        .move {
            background: white;
            padding: 10px 15px;
            border-radius: 5px;
            font-weight: 600;
            color: #2E7D32;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        
        .error {
            background: #ffebee;
            padding: 15px;
            border-radius: 8px;
            border-left: 4px solid #f44336;
            color: #c62828;
            margin-top: 20px;
        }
        
        .debug-info {
            background: #f5f5f5;
            padding: 20px;
            border-radius: 8px;
            margin-top: 20px;
            border: 2px solid #ddd;
        }
        
        .debug-info h3 {
            color: #333;
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .debug-section {
            background: white;
            padding: 12px;
            border-radius: 5px;
            margin-bottom: 10px;
            font-family: 'Courier New', monospace;
            font-size: 13px;
        }
        
        .debug-label {
            font-weight: bold;
            color: #667eea;
            margin-right: 8px;
        }
        
        .debug-value {
            color: #333;
        }
        
        .wall-list {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin-top: 5px;
        }
        
        .wall-item {
            background: #e9ecef;
            padding: 4px 8px;
            border-radius: 3px;
            font-size: 11px;
        }
        
        .copy-btn {
            background: #28a745;
            padding: 8px 15px;
            font-size: 12px;
            margin-top: 10px;
        }
        
        .copy-btn:hover {
            background: #218838;
        }
        
        .execute-btn {
            background: #ff6b6b;
            padding: 12px 30px;
            font-size: 16px;
            margin-left: 10px;
            display: none;
        }
        
        .execute-btn:hover {
            background: #ee5a52;
        }
        
        .execute-btn.visible {
            display: inline-block;
        }
        
        .simulation {
            background: #fff3cd;
            padding: 20px;
            border-radius: 8px;
            border-left: 4px solid #ffc107;
            margin-top: 20px;
        }
        
        .simulation h3 {
            color: #856404;
            margin-bottom: 15px;
        }
        
        .simulation-controls {
            display: flex;
            gap: 10px;
            margin-top: 15px;
            flex-wrap: wrap;
            align-items: center;
        }
        
        .simulation-controls button {
            padding: 10px 20px;
            font-size: 14px;
        }
        
        .step-info {
            background: white;
            padding: 15px;
            border-radius: 5px;
            margin-top: 15px;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            border-left: 4px solid #ffc107;
        }
        
        .step-info.failed {
            background: #ffebee;
            border-left: 4px solid #f44336;
        }
        
        .step-info.success {
            background: #e8f5e9;
            border-left: 4px solid #4CAF50;
        }
        
        .cell.sim-player {
            background: #81C784;
            animation: pulse 0.5s;
        }
        
        .cell.sim-guard {
            background: #E57373;
            animation: pulse 0.5s;
        }
        
        .cell.collision {
            background: #d32f2f;
            animation: shake 0.5s;
        }
        
        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }
        
        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(-5px); }
            75% { transform: translateX(5px); }
        }
        
        .speed-control {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .speed-control label {
            font-weight: 600;
            color: #856404;
        }
        
        .speed-control input {
            width: 100px;
        }
        
        .center {
            text-align: center;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üîì BitLife Prison Escape Solver</h1>
        <p class="subtitle">Set up your puzzle and find the escape route!</p>
        
        <div class="setup">
            <div class="setup-row">
                <label>Grid Width:</label>
                <input type="number" id="gridWidth" min="3" max="10" value="5">
                <label style="margin-left: 15px;">Grid Height:</label>
                <input type="number" id="gridHeight" min="3" max="10" value="5">
                <button onclick="createGrid()">Create Grid</button>
            </div>
        </div>
        
        <div class="instructions">
            <h3>üìã Instructions</h3>
            <ul>
                <li>Choose grid size and click "Create Grid"</li>
                <li>Select a mode and click on cells to place player, guard, or walls</li>
                <li>For exits, click one of the üö™ markers around the outside of the grid</li>
                <li>For walls, click on the edges between cells (not the center)</li>
                <li>Click "Solve Puzzle" to find the escape route</li>
                <li><strong>Rule:</strong> Guard moves TWICE for every move you make, always horizontally first!</li>
            </ul>
        </div>
        
        <div class="mode-buttons">
            <button class="mode-btn active" onclick="setMode('player')">üßç Player Start</button>
            <button class="mode-btn" onclick="setMode('guard')">üëÆ Guard</button>
            <button class="mode-btn" onclick="setMode('exit')">üö™ Exit</button>
            <button class="mode-btn" onclick="setMode('wall')">üß± Toggle Wall</button>
        </div>
        
        <div class="center">
            <div class="grid-container" id="gridWrapper" style="position: relative;">
                <div id="grid" class="grid"></div>
            </div>
        </div>
        
        <div class="center">
            <button onclick="solvePuzzle()" style="font-size: 16px; padding: 12px 30px;">üéØ Solve Puzzle</button>
            <button id="executeBtn" class="execute-btn" onclick="executePath()">‚ñ∂Ô∏è Execute & Verify Path</button>
            <button onclick="clearGrid()" style="font-size: 16px; padding: 12px 30px; background: #666; margin-left: 10px;">üîÑ Clear</button>
            <button onclick="toggleDebugInfo()" style="font-size: 16px; padding: 12px 30px; background: #28a745; margin-left: 10px;">üìã Show Setup Info</button>
        </div>
        
        <div id="simulation"></div>
        
        <div id="result"></div>
        
        <div id="debugInfo" style="display: none;"></div>
    </div>

    <script>
        let gridWidth = 5;
        let gridHeight = 5;
        let mode = 'player';
        let playerPos = null;
        let guardPos = null;
        let exitPos = null;
        let exitSide = null; // 'top', 'right', 'bottom', 'left'
        let walls = {};
        let currentPath = null; // Store the generated path for execution
        let simulationSteps = [];
        let currentStep = 0;
        let isPlaying = false;
        let playbackSpeed = 500; // milliseconds between steps

        function setMode(newMode) {
            mode = newMode;
            document.querySelectorAll('.mode-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            event.target.classList.add('active');
        }

        function createGrid() {
            gridWidth = parseInt(document.getElementById('gridWidth').value);
            gridHeight = parseInt(document.getElementById('gridHeight').value);
            
            if (gridWidth < 3 || gridWidth > 10 || gridHeight < 3 || gridHeight > 10) {
                alert('Grid dimensions must be between 3 and 10');
                return;
            }
            
            playerPos = null;
            guardPos = null;
            exitPos = null;
            exitSide = null;
            walls = {};
            
            const grid = document.getElementById('grid');
            grid.innerHTML = '';
            grid.style.gridTemplateColumns = `repeat(${gridWidth}, 50px)`;
            
            for (let row = 0; row < gridHeight; row++) {
                for (let col = 0; col < gridWidth; col++) {
                    const cell = document.createElement('div');
                    cell.className = 'cell';
                    cell.dataset.row = row;
                    cell.dataset.col = col;
                    cell.onclick = (e) => handleCellClick(row, col, e);
                    grid.appendChild(cell);
                }
            }
            
            createExitZones();
            document.getElementById('result').innerHTML = '';
        }

        function createExitZones() {
            const wrapper = document.getElementById('gridWrapper');
            const existingExits = wrapper.querySelectorAll('.exit-marker');
            existingExits.forEach(el => el.remove());
            
            const cellSize = 50;
            const gap = 20;
            const gridPixelWidth = gridWidth * cellSize;
            const gridPixelHeight = gridHeight * cellSize;
            
            // Top exits
            for (let col = 0; col < gridWidth; col++) {
                createExitMarker('top', 0, col, gap + col * cellSize + cellSize / 2, gap - 20);
            }
            
            // Bottom exits
            for (let col = 0; col < gridWidth; col++) {
                createExitMarker('bottom', gridHeight - 1, col, gap + col * cellSize + cellSize / 2, gap + gridPixelHeight + 10);
            }
            
            // Left exits
            for (let row = 0; row < gridHeight; row++) {
                createExitMarker('left', row, 0, gap - 20, gap + row * cellSize + cellSize / 2);
            }
            
            // Right exits
            for (let row = 0; row < gridHeight; row++) {
                createExitMarker('right', row, gridWidth - 1, gap + gridPixelWidth + 10, gap + row * cellSize + cellSize / 2);
            }
        }

        function createExitMarker(side, row, col, left, top) {
            const wrapper = document.getElementById('gridWrapper');
            const marker = document.createElement('div');
            marker.className = 'exit-marker';
            marker.innerHTML = 'üö™';
            marker.style.left = left + 'px';
            marker.style.top = top + 'px';
            marker.onclick = () => placeExit(side, row, col);
            wrapper.appendChild(marker);
        }

        function placeExit(side, row, col) {
            if (mode !== 'exit') return;
            
            exitSide = side;
            exitPos = {row, col};
            updateGrid();
            updateDebugInfo();
        }

        function handleCellClick(row, col, e) {
            const cell = e.target.closest('.cell');
            const rect = cell.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            
            if (mode === 'wall') {
                const edgeThreshold = 12;
                if (y < edgeThreshold) toggleWall(row, col, 'top');
                else if (x > rect.width - edgeThreshold) toggleWall(row, col, 'right');
                else if (y > rect.height - edgeThreshold) toggleWall(row, col, 'bottom');
                else if (x < edgeThreshold) toggleWall(row, col, 'left');
            } else {
                placeItem(row, col);
            }
        }

        function placeItem(row, col) {
            if (mode === 'player') {
                playerPos = {row, col};
                updateGrid();
                updateDebugInfo();
            } else if (mode === 'guard') {
                guardPos = {row, col};
                updateGrid();
                updateDebugInfo();
            }
            // Exit can only be placed via exit markers outside grid
        }

        function toggleWall(row, col, side) {
            const key = `${row},${col},${side}`;
            walls[key] = !walls[key];
            updateGrid();
            updateDebugInfo();
        }

        function updateGrid() {
            document.querySelectorAll('.cell').forEach(cell => {
                const row = parseInt(cell.dataset.row);
                const col = parseInt(cell.dataset.col);
                
                cell.className = 'cell';
                cell.innerHTML = '';
                
                if (playerPos && playerPos.row === row && playerPos.col === col) {
                    cell.classList.add('player');
                    cell.innerHTML = 'üë§';
                } else if (guardPos && guardPos.row === row && guardPos.col === col) {
                    cell.classList.add('guard');
                    cell.innerHTML = 'üëÆ';
                }
                
                ['top', 'right', 'bottom', 'left'].forEach(side => {
                    if (walls[`${row},${col},${side}`]) {
                        const wallDiv = document.createElement('div');
                        wallDiv.className = `wall-${side}`;
                        cell.appendChild(wallDiv);
                    }
                });
            });
            
            // Highlight selected exit marker
            document.querySelectorAll('.exit-marker').forEach(marker => {
                marker.style.background = '#FFD700';
                marker.style.transform = 'scale(1)';
            });
            
            if (exitPos && exitSide) {
                const markers = document.querySelectorAll('.exit-marker');
                markers.forEach(marker => {
                    const rect = marker.getBoundingClientRect();
                    const wrapperRect = document.getElementById('gridWrapper').getBoundingClientRect();
                    // Find and highlight the selected exit
                    if (shouldHighlightMarker(marker, exitPos, exitSide)) {
                        marker.style.background = '#FFA500';
                        marker.style.transform = 'scale(1.2)';
                    }
                });
            }
        }

        function shouldHighlightMarker(marker, pos, side) {
            const markerIndex = Array.from(document.querySelectorAll('.exit-marker')).indexOf(marker);
            let expectedIndex = -1;
            
            if (side === 'top') expectedIndex = pos.col;
            else if (side === 'bottom') expectedIndex = gridWidth + pos.col;
            else if (side === 'left') expectedIndex = 2 * gridWidth + pos.row;
            else if (side === 'right') expectedIndex = 2 * gridWidth + gridHeight + pos.row;
            
            return markerIndex === expectedIndex;
        }

        function clearGrid() {
            playerPos = null;
            guardPos = null;
            exitPos = null;
            exitSide = null;
            walls = {};
            currentPath = null;
            simulationSteps = [];
            currentStep = 0;
            isPlaying = false;
            updateGrid();
            document.getElementById('result').innerHTML = '';
            document.getElementById('simulation').innerHTML = '';
            document.getElementById('executeBtn').classList.remove('visible');
            updateDebugInfo();
        }

        function toggleDebugInfo() {
            const debugDiv = document.getElementById('debugInfo');
            if (debugDiv.style.display === 'none') {
                debugDiv.style.display = 'block';
                updateDebugInfo();
                event.target.textContent = 'üìã Hide Setup Info';
            } else {
                debugDiv.style.display = 'none';
                event.target.textContent = 'üìã Show Setup Info';
            }
        }

        function updateDebugInfo() {
            const debugDiv = document.getElementById('debugInfo');
            if (debugDiv.style.display === 'none') return;
            
            // Collect wall information
            const wallsList = [];
            for (const [key, value] of Object.entries(walls)) {
                if (value) {
                    const [row, col, side] = key.split(',');
                    wallsList.push({row: parseInt(row), col: parseInt(col), side});
                }
            }
            
            // Sort walls for easier reading
            wallsList.sort((a, b) => {
                if (a.row !== b.row) return a.row - b.row;
                if (a.col !== b.col) return a.col - b.col;
                return a.side.localeCompare(b.side);
            });
            
            const wallsHTML = wallsList.length > 0 
                ? wallsList.map(w => `<span class="wall-item">Cell(${w.row},${w.col}) - ${w.side}</span>`).join('')
                : '<span style="color: #999;">No walls placed</span>';
            
            const setupData = {
                gridWidth,
                gridHeight,
                playerPos: playerPos ? `Row ${playerPos.row}, Col ${playerPos.col}` : 'Not placed',
                guardPos: guardPos ? `Row ${guardPos.row}, Col ${guardPos.col}` : 'Not placed',
                exitPos: exitPos ? `Row ${exitPos.row}, Col ${exitPos.col} (${exitSide} side)` : 'Not placed',
                wallCount: wallsList.length
            };
            
            debugDiv.innerHTML = `
                <div class="debug-info">
                    <h3>üîç Current Setup Information</h3>
                    
                    <div class="debug-section">
                        <span class="debug-label">Grid Size:</span>
                        <span class="debug-value">${setupData.gridWidth} (width) x ${setupData.gridHeight} (height)</span>
                    </div>
                    
                    <div class="debug-section">
                        <span class="debug-label">Player Position:</span>
                        <span class="debug-value">${setupData.playerPos}</span>
                    </div>
                    
                    <div class="debug-section">
                        <span class="debug-label">Guard Position:</span>
                        <span class="debug-value">${setupData.guardPos}</span>
                    </div>
                    
                    <div class="debug-section">
                        <span class="debug-label">Exit Position:</span>
                        <span class="debug-value">${setupData.exitPos}</span>
                    </div>
                    
                    <div class="debug-section">
                        <span class="debug-label">Walls (${setupData.wallCount} total):</span>
                        <div class="wall-list">${wallsHTML}</div>
                    </div>
                    
                    <button class="copy-btn" onclick="copySetupInfo()">üìã Copy Setup Info to Clipboard</button>
                </div>
            `;
        }

        function copySetupInfo() {
            const wallsList = [];
            for (const [key, value] of Object.entries(walls)) {
                if (value) {
                    const [row, col, side] = key.split(',');
                    wallsList.push(`Cell(${row},${col}) - ${side}`);
                }
            }
            
            const setupText = `
BitLife Prison Escape Setup
============================
Grid Size: ${gridWidth} (width) x ${gridHeight} (height)
Player Position: ${playerPos ? `Row ${playerPos.row}, Col ${playerPos.col}` : 'Not placed'}
Guard Position: ${guardPos ? `Row ${guardPos.row}, Col ${guardPos.col}` : 'Not placed'}
Exit Position: ${exitPos ? `Row ${exitPos.row}, Col ${exitPos.col} (${exitSide} side)` : 'Not placed'}

Walls (${wallsList.length} total):
${wallsList.length > 0 ? wallsList.join('\n') : 'No walls placed'}
            `.trim();
            
            navigator.clipboard.writeText(setupText).then(() => {
                const btn = event.target;
                const originalText = btn.textContent;
                btn.textContent = '‚úÖ Copied!';
                btn.style.background = '#218838';
                setTimeout(() => {
                    btn.textContent = originalText;
                    btn.style.background = '#28a745';
                }, 2000);
            }).catch(err => {
                alert('Failed to copy to clipboard. Please copy manually:\n\n' + setupText);
            });
        }

        function executePath() {
            if (!currentPath) {
                alert('Please solve the puzzle first!');
                return;
            }

            // Reset simulation state
            currentStep = 0;
            isPlaying = false;
            simulationSteps = [];
            
            // Initialize simulation state
            let simPlayerPos = {...playerPos};
            let simGuardPos = {...guardPos};
            let stepNum = 0;
            let failed = false;
            let failureReason = '';
            
            simulationSteps.push({
                step: stepNum,
                action: 'START',
                playerPos: {...simPlayerPos},
                guardPos: {...simGuardPos},
                status: 'success'
            });
            
            // Execute each move in the path
            for (let i = 1; i < currentPath.length; i++) {
                stepNum++;
                
                if (currentPath[i] === 'EXIT') {
                    // Final exit move
                    simulationSteps.push({
                        step: stepNum,
                        action: `EXIT ${exitSide.toUpperCase()}`,
                        playerPos: {...simPlayerPos},
                        guardPos: {...simGuardPos},
                        status: 'success',
                        message: 'üéâ Successfully escaped!'
                    });
                    break;
                }
                
                const newPlayerPos = currentPath[i];
                
                // Determine move direction
                let moveDir = '';
                if (newPlayerPos.row < simPlayerPos.row) moveDir = 'UP';
                else if (newPlayerPos.row > simPlayerPos.row) moveDir = 'DOWN';
                else if (newPlayerPos.col > simPlayerPos.col) moveDir = 'RIGHT';
                else if (newPlayerPos.col < simPlayerPos.col) moveDir = 'LEFT';
                
                // Check if move is valid (no walls blocking)
                const directions = {
                    'UP': {wall: 'top', neighborWall: 'bottom', dr: -1, dc: 0},
                    'DOWN': {wall: 'bottom', neighborWall: 'top', dr: 1, dc: 0},
                    'RIGHT': {wall: 'right', neighborWall: 'left', dr: 0, dc: 1},
                    'LEFT': {wall: 'left', neighborWall: 'right', dr: 0, dc: -1}
                };
                
                const dir = directions[moveDir];
                if (walls[`${simPlayerPos.row},${simPlayerPos.col},${dir.wall}`]) {
                    failed = true;
                    failureReason = `Wall blocks ${moveDir} movement from (${simPlayerPos.row},${simPlayerPos.col})`;
                    simulationSteps.push({
                        step: stepNum,
                        action: `Move ${moveDir}`,
                        playerPos: {...simPlayerPos},
                        guardPos: {...simGuardPos},
                        status: 'failed',
                        message: failureReason
                    });
                    break;
                }
                
                // Move player
                simPlayerPos = {...newPlayerPos};
                
                // Move guard twice toward new player position
                const newGuardPos = moveGuard(simGuardPos, simPlayerPos);
                simGuardPos = newGuardPos;
                
                // Check if guard caught player
                if (simPlayerPos.row === simGuardPos.row && simPlayerPos.col === simGuardPos.col) {
                    failed = true;
                    failureReason = `Guard caught player at position (${simPlayerPos.row},${simPlayerPos.col})`;
                    simulationSteps.push({
                        step: stepNum,
                        action: `Move ${moveDir}`,
                        playerPos: {...simPlayerPos},
                        guardPos: {...simGuardPos},
                        status: 'failed',
                        message: failureReason,
                        collision: true
                    });
                    break;
                }
                
                simulationSteps.push({
                    step: stepNum,
                    action: `Move ${moveDir}`,
                    playerPos: {...simPlayerPos},
                    guardPos: {...simGuardPos},
                    status: 'success'
                });
            }
            
            showSimulationControls(failed, failureReason);
            displayStep(0);
        }

        function showSimulationControls(failed, failureReason) {
            const simulationDiv = document.getElementById('simulation');
            
            const summaryClass = failed ? 'error' : 'solution';
            const summaryIcon = failed ? '‚ùå' : '‚úÖ';
            const summaryTitle = failed ? 'Path Verification FAILED' : 'Path Verification SUCCESSFUL';
            
            let summaryContent = failed ? `
                <div class="${summaryClass}" style="margin-top: 20px;">
                    <h3>${summaryIcon} ${summaryTitle}</h3>
                    <p><strong>Failure Reason:</strong> ${failureReason}</p>
                    <p><strong>Failed at Step:</strong> ${simulationSteps.length - 1} of ${currentPath.length - 1}</p>
                </div>
            ` : '';
            
            simulationDiv.innerHTML = `
                <div class="simulation">
                    <h3>üîç Path Execution Simulation</h3>
                    <div class="simulation-controls">
                        <button onclick="playSimulation()" id="playBtn">‚ñ∂Ô∏è Play</button>
                        <button onclick="pauseSimulation()">‚è∏Ô∏è Pause</button>
                        <button onclick="stepForward()" id="nextBtn">‚è≠Ô∏è Next Step</button>
                        <button onclick="stepBackward()" id="prevBtn">‚èÆÔ∏è Previous Step</button>
                        <button onclick="resetSimulation()">üîÑ Reset</button>
                        <div class="speed-control">
                            <label>Speed:</label>
                            <input type="range" min="100" max="2000" value="500" step="100" 
                                   oninput="updateSpeed(this.value)" style="width: 150px;">
                            <span id="speedLabel">0.5s</span>
                        </div>
                    </div>
                    <div id="stepInfo" class="step-info"></div>
                </div>
                ${summaryContent}
            `;
        }

        function displayStep(stepIndex) {
            if (stepIndex < 0 || stepIndex >= simulationSteps.length) return;
            
            currentStep = stepIndex;
            const step = simulationSteps[stepIndex];
            
            // Clear the grid completely first
            document.querySelectorAll('.cell').forEach(cell => {
                const row = parseInt(cell.dataset.row);
                const col = parseInt(cell.dataset.col);
                
                cell.className = 'cell';
                cell.innerHTML = '';
                
                // Re-add walls
                ['top', 'right', 'bottom', 'left'].forEach(side => {
                    if (walls[`${row},${col},${side}`]) {
                        const wallDiv = document.createElement('div');
                        wallDiv.className = `wall-${side}`;
                        cell.appendChild(wallDiv);
                    }
                });
            });
            
            // Show ONLY the current simulation positions
            const playerCell = document.querySelector(`[data-row="${step.playerPos.row}"][data-col="${step.playerPos.col}"]`);
            const guardCell = document.querySelector(`[data-row="${step.guardPos.row}"][data-col="${step.guardPos.col}"]`);
            
            if (step.collision) {
                // Show collision
                if (playerCell) {
                    playerCell.classList.add('collision');
                    playerCell.innerHTML = 'üí•';
                }
            } else {
                if (playerCell) {
                    playerCell.classList.add('player');
                    playerCell.innerHTML = 'üë§';
                }
                if (guardCell && guardCell !== playerCell) {
                    guardCell.classList.add('guard');
                    guardCell.innerHTML = 'üëÆ';
                }
            }
            
            // Update step info
            const stepInfoDiv = document.getElementById('stepInfo');
            const statusClass = step.status === 'failed' ? 'failed' : step.status === 'success' && step.message ? 'success' : '';
            
            let infoHTML = `
                <strong>Step ${step.step} of ${simulationSteps.length - 1}:</strong> ${step.action}<br>
                üë§ Player Position: (${step.playerPos.row}, ${step.playerPos.col})<br>
                üëÆ Guard Position: (${step.guardPos.row}, ${step.guardPos.col})
            `;
            
            if (step.message) {
                infoHTML += `<br><strong style="color: ${step.status === 'failed' ? '#c62828' : '#2E7D32'};">${step.message}</strong>`;
            }
            
            stepInfoDiv.className = `step-info ${statusClass}`;
            stepInfoDiv.innerHTML = infoHTML;
            
            // Update button states
            updateButtonStates();
        }

        function updateButtonStates() {
            const prevBtn = document.getElementById('prevBtn');
            const nextBtn = document.getElementById('nextBtn');
            const playBtn = document.getElementById('playBtn');
            
            if (prevBtn) prevBtn.disabled = currentStep === 0;
            if (nextBtn) nextBtn.disabled = currentStep === simulationSteps.length - 1;
            if (playBtn) playBtn.disabled = currentStep === simulationSteps.length - 1;
        }

        function playSimulation() {
            if (isPlaying) return;
            isPlaying = true;
            
            const interval = setInterval(() => {
                if (currentStep >= simulationSteps.length - 1 || !isPlaying) {
                    clearInterval(interval);
                    isPlaying = false;
                    updateButtonStates();
                    return;
                }
                stepForward();
            }, playbackSpeed);
        }

        function pauseSimulation() {
            isPlaying = false;
        }

        function stepForward() {
            if (currentStep < simulationSteps.length - 1) {
                displayStep(currentStep + 1);
            }
        }

        function stepBackward() {
            if (currentStep > 0) {
                displayStep(currentStep - 1);
            }
        }

        function resetSimulation() {
            pauseSimulation();
            displayStep(0);
        }

        function updateSpeed(value) {
            playbackSpeed = parseInt(value);
            document.getElementById('speedLabel').textContent = (value / 1000).toFixed(1) + 's';
        }

        function solvePuzzle() {
            document.getElementById('simulation').innerHTML = '';
            
            if (!playerPos || !guardPos || !exitPos) {
                document.getElementById('result').innerHTML = 
                    '<div class="error">‚ùå Please place the player, guard, and exit on the grid.</div>';
                document.getElementById('executeBtn').classList.remove('visible');
                currentPath = null;
                return;
            }

            const path = findPath();
            if (path) {
                currentPath = path;
                displaySolution(path);
                document.getElementById('executeBtn').classList.add('visible');
            } else {
                currentPath = null;
                document.getElementById('executeBtn').classList.remove('visible');
                document.getElementById('result').innerHTML = 
                    '<div class="error">‚ùå No safe path found! The guard blocks all routes.</div>';
            }
        }

        function findPath() {
            const queue = [{pos: playerPos, path: [playerPos], guardPos: guardPos}];
            const visited = new Set();
            visited.add(`${playerPos.row},${playerPos.col},${guardPos.row},${guardPos.col}`);

            const directions = [
                {dr: -1, dc: 0, name: 'UP', wall: 'top', neighborWall: 'bottom'},
                {dr: 0, dc: 1, name: 'RIGHT', wall: 'right', neighborWall: 'left'},
                {dr: 1, dc: 0, name: 'DOWN', wall: 'bottom', neighborWall: 'top'},
                {dr: 0, dc: -1, name: 'LEFT', wall: 'left', neighborWall: 'right'}
            ];

            while (queue.length > 0) {
                const {pos, path, guardPos: gPos} = queue.shift();

                // Check if reached exit cell
                if (pos.row === exitPos.row && pos.col === exitPos.col) {
                    // Need one more move to exit through the designated side
                    const exitDir = directions.find(d => d.wall === exitSide);
                    if (exitDir) {
                        return [...path, 'EXIT'];
                    }
                }

                for (const dir of directions) {
                    const newRow = pos.row + dir.dr;
                    const newCol = pos.col + dir.dc;

                    // Check if this is an exit move
                    if (pos.row === exitPos.row && pos.col === exitPos.col && dir.wall === exitSide) {
                        return [...path, 'EXIT'];
                    }

                    if (newRow < 0 || newRow >= gridHeight || newCol < 0 || newCol >= gridWidth) continue;
                    if (walls[`${pos.row},${pos.col},${dir.wall}`]) continue;
                    if (walls[`${newRow},${newCol},${dir.neighborWall}`]) continue;

                    // Guard moves twice toward the new player position
                    const newGuardPos = moveGuard(gPos, {row: newRow, col: newCol});
                    
                    if (newRow === newGuardPos.row && newCol === newGuardPos.col) continue;

                    const stateKey = `${newRow},${newCol},${newGuardPos.row},${newGuardPos.col}`;
                    if (visited.has(stateKey)) continue;

                    visited.add(stateKey);
                    queue.push({
                        pos: {row: newRow, col: newCol},
                        path: [...path, {row: newRow, col: newCol}],
                        guardPos: newGuardPos
                    });
                }
            }

            return null;
        }

        function moveGuard(gPos, playerNewPos) {
            // Guard makes TWO moves, always trying to move horizontally first
            let currentPos = {...gPos};
            
            for (let moveCount = 0; moveCount < 2; moveCount++) {
                const rowDiff = playerNewPos.row - currentPos.row;
                const colDiff = playerNewPos.col - currentPos.col;
                
                // Try horizontal move first (BitLife rule)
                if (colDiff !== 0) {
                    const dc = colDiff > 0 ? 1 : -1;
                    const newCol = currentPos.col + dc;
                    const wall = dc > 0 ? 'right' : 'left';
                    const neighborWall = dc > 0 ? 'left' : 'right';
                    
                    if (newCol >= 0 && newCol < gridWidth &&
                        !walls[`${currentPos.row},${currentPos.col},${wall}`] &&
                        !walls[`${currentPos.row},${newCol},${neighborWall}`]) {
                        currentPos.col = newCol;
                        continue;
                    }
                }
                
                // If can't move horizontally or already aligned horizontally, try vertical
                if (rowDiff !== 0) {
                    const dr = rowDiff > 0 ? 1 : -1;
                    const newRow = currentPos.row + dr;
                    const wall = dr > 0 ? 'bottom' : 'top';
                    const neighborWall = dr > 0 ? 'top' : 'bottom';
                    
                    if (newRow >= 0 && newRow < gridHeight &&
                        !walls[`${currentPos.row},${currentPos.col},${wall}`] &&
                        !walls[`${newRow},${currentPos.col},${neighborWall}`]) {
                        currentPos.row = newRow;
                        continue;
                    }
                }
                
                // If guard can't move at all, stay in place for remaining moves
                break;
            }
            
            return currentPos;
        }

        function displaySolution(path) {
            // Don't modify the grid during solution display - just show the path
            document.querySelectorAll('.cell').forEach(cell => {
                const row = parseInt(cell.dataset.row);
                const col = parseInt(cell.dataset.col);
                
                cell.className = 'cell';
                cell.innerHTML = '';
                
                // Show original player and guard positions
                if (playerPos && playerPos.row === row && playerPos.col === col) {
                    cell.classList.add('player');
                    cell.innerHTML = 'üë§';
                } else if (guardPos && guardPos.row === row && guardPos.col === col) {
                    cell.classList.add('guard');
                    cell.innerHTML = 'üëÆ';
                }
                
                // Re-add walls
                ['top', 'right', 'bottom', 'left'].forEach(side => {
                    if (walls[`${row},${col},${side}`]) {
                        const wallDiv = document.createElement('div');
                        wallDiv.className = `wall-${side}`;
                        cell.appendChild(wallDiv);
                    }
                });
            });
            
            // Highlight the path
            for (let i = 1; i < path.length; i++) {
                if (path[i] === 'EXIT') break;
                const cell = document.querySelector(`[data-row="${path[i].row}"][data-col="${path[i].col}"]`);
                if (cell && !cell.classList.contains('player')) {
                    cell.classList.add('path');
                }
            }

            const moves = [];
            for (let i = 1; i < path.length; i++) {
                if (path[i] === 'EXIT') {
                    const exitDirMap = {
                        'top': 'UP ‚¨ÜÔ∏è (EXIT)',
                        'right': 'RIGHT ‚û°Ô∏è (EXIT)',
                        'bottom': 'DOWN ‚¨áÔ∏è (EXIT)',
                        'left': 'LEFT ‚¨ÖÔ∏è (EXIT)'
                    };
                    moves.push(exitDirMap[exitSide]);
                    break;
                }
                
                const prev = path[i - 1];
                const curr = path[i];
                
                if (curr.row < prev.row) moves.push('UP ‚¨ÜÔ∏è');
                else if (curr.row > prev.row) moves.push('DOWN ‚¨áÔ∏è');
                else if (curr.col > prev.col) moves.push('RIGHT ‚û°Ô∏è');
                else if (curr.col < prev.col) moves.push('LEFT ‚¨ÖÔ∏è');
            }

            const movesHTML = moves.map((m, i) => `<div class="move">${i + 1}. ${m}</div>`).join('');
            
            document.getElementById('result').innerHTML = `
                <div class="solution">
                    <h3>‚úÖ Solution Found! (${moves.length} moves)</h3>
                    <div class="moves">${movesHTML}</div>
                </div>
            `;
        }

        createGrid();
    </script>
</body>
</html>